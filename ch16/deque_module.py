# deque_module.py

from collections import deque

dq = deque()

dq.append(1)
dq.append(2)
print(dq)           # deque([1, 2])
dq.appendleft(0)
dq.pop()    
print(dq)           # deque([0, 1])
dq.appendleft(-11)
print(dq)           # deque([-11, 0, 1])
dq.popleft()
print(dq)           # deque([0, 1])


# 📌 알고리즘 성능 측정 방법 (빅오 표기법 -> 알고리즘이 얼마나 빠른지를 수학적으로 표현하는 방법)
# - 알고리즘의 실행 속도를 평가하는 방식
# - 주요 복잡도 (예시):
#   O(1): 상수 시간 (배열 요소 접근, 인덱스 접근 등) 
#       : 항상 일정한 시간으로 처리됨
#       : 책 1,000권 중에서 “5번째 책만” 꺼내는 건 항상 같은 시간 걸림 (책이 10권이든 1000권이든 상관없음)

#   O(n): 선형 시간 (리스트 순회, for문, 전체 순회) 
#       : (n크기에 따라) 입력 크기가 커질수록 걸리는 시간도 비례해서 증가 
#       :책이 많아질수록 책 한 권씩 읽는 데 걸리는 시간이 늘어남

#   O(log n): 로그 시간 (이진 탐색) 
#           : 입력이 커져도 시간 증가 속도가 매우 느림
#           : 책 1,000권에서 찾을 때 처음부터 하나씩 보는 대신 반씩 나눠서 찾으면 속도가 훨씬 빨라짐

#   O(n log n): 로그 선형 시간 (퀵 정렬, 병합 정렬 등) 
#             : 선형보다 조금 느리지만 여전히 효율적
#             : 1,000권 책을 정렬하려고 절반씩 나눠서 정리하고 마지막에 합치는 느낌

#   O(n²): 이차 시간 (이중 반복문, 비교 정렬)
#         : 입력 크기가 커질수록 시간이 급격히 폭발
#         : 모든 책을 서로 비교해야 하는 상황

# 입력 크기(n)가 커질수록 O(1) → O(n) → O(n log n) → O(n²) 순으로 느려짐


# 📌 리스트 구조: 동작별 기본 개념
# - list.append() / list.pop(): 사용 → O(1) (단, pop(0)은 O(n))

# - deque: 큐 구조로, 이중 연결 리스트 또는 고정 크기 배열 구조
# - list.append() vs deque.append(): 거의 동일
# - list.pop(0) vs deque.popleft(): 성능 차이 큼
#   list.pop(0)  -> O(n)
#   deque.popleft() -> O(1)


# 알고리즘의 효율성은 빅오 표기법으로 표현합니다.
# 리스트는 뒤에서 꺼낼 때 빠르지만 앞에서 꺼내는 건 느립니다.
# deque는 앞뒤 모두 빠르게 접근할 수 있어 큐나 스택 구현 시 자주 사용됩니다.